package databaseHandler

import (
	"errors"
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/BaileyJM02/Hue-API/pkg/logger"
	"github.com/bwmarrin/discordgo"
	"github.com/globalsign/mgo"
	"github.com/globalsign/mgo/bson"
	"mvdan.cc/xurls"
)

type MessageAttachment struct {
	_ID      string `bson:"_id"`
	ID       string `bson:"id"`
	URL      string `bson:"url"`
	ProxyURL string `bson:"proxyurl"`
	Filename string `bson:"filename"`
}

type User struct {
	ID            string `bson:"id"`
	Username      string `bson:"username"`      // The user's username.
	Avatar        string `bson:"avatar"`        // The hash of the user's avatar. Use Session.UserAvatar to retrieve the avatar itself.
	Locale        string `bson:"locale"`        // The user's chosen language option.
	Discriminator string `bson:"discriminator"` // The discriminator of the user (4 numbers after name).
	Verified      bool   `bson:"verified"`      // Whether the user's email is verified.
	Bot           bool   `bson:"bot"`           // Whether the user is a bot.
}

type Message struct {
	_ID             string                `bson:"_id"` // The ID of the message.
	ID              string                `bson:"id"`
	CreatedTime     time.Time             `bson:"createdtime"`
	ChannelID       string                `bson:"channelid"`       // The ID of the channel in which the message was sent.
	GuildID         string                `bson:"guildid"`         // The ID of the guild in which the message was sent.
	MentionRoles    []string              `bson:"mentionroles"`    // The roles mentioned in the message.
	Tts             bool                  `bson:"tts"`             // Whether the message is text-to-speech.
	MentionEveryone bool                  `bson:"mentioneveryone"` // Whether the message mentions everyone.
	AuthorID        string                `bson:"authorid"`        // The id of the author of the message.
	Attachments     []MessageAttachment   `bson:"attachments"`     // A list of attachments present in the message.
	Mentions        []string              `bson:"mentions"`        // A list of users mentioned in the message.
	Type            discordgo.MessageType `bson:"type"`            // The type of the message.
	WebhookID       string                `bson:"webhookid"`       // The webhook ID of the message, if it was generated by a webhook
}

type Member struct {
	_ID             string    `bson:"_id"` //User.ID
	ID              string    `bson:"id"`
	GuildID         string    `bson:"guildid"`         // The guild ID on which the member exists.
	JoinedAt        time.Time `bson:"joinedat"`        // The time at which the member joined the guild
	Nick            string    `bson:"nick"`            // The nickname of the member, if they have one.
	User            User      `bson:"user"`            // The underlying user on which the member is based.
	Roles           []string  `bson:"roles"`           // A list of IDs of the roles which are possessed by the member.
	MessagesSent    int       `bson:"messagessent"`    // Number of messages the user has sent
	AttachmentsSent int       `bson:"attachmentssent"` // Number of attachments the user has sent
	LinksSent       int       `bson:"linkssent"`       // Number of messages the user has sent
	TimesMentioned  int       `bson:"timesmentioned"`  // Number of times a user, other than self mentioned them
}

type MessageHelper struct {
	Message *discordgo.MessageCreate
	Member  *discordgo.Member
}

type CheckHelper struct {
	Guild   *discordgo.Guild
	Members []*discordgo.Member
}

type GuildStats struct {
	_ID           string `bson:"_id"` // Guild ID
	ID            string `bson:"id"`
	TotalMessages int    `bson:"totalmessages"` // Messages all time
	MessagesTMO   int    `bson:"messagestmo"`   // Messages this month (last 30 days)
	MessagesTD    int    `bson:"messagestd"`    // Messages this day (last 24h)
	MessagesTH    int    `bson:"messagesth"`    // Messages this hour (last 60 minutes)
	MessagesTm    int    `bson:"messagestm"`    // Messages this minute (last 60 seconds)

	TotalMembers int `bson:"totalmembers"` // Members all time
	MembersTMO   int `bson:"memberstmo"`   // Members this month (last 30 days)
	MembersTD    int `bson:"memberstd"`    // Members this day (last 24h)
	MembersTH    int `bson:"membersth"`    // Members this hour (last 60 minutes)
	MembersTm    int `bson:"memberstm"`    // Members this minute (last 60 seconds)

	AttachmentsSent int `bson:"attachmentssent"` // Number of attachments sent
	LinksSent       int `bson:"linkssent"`       // Number of links sent
	Mentions        int `bson:"mentions"`        // Number of mentions made
}
type Settings struct {
	Prefix string `bson:"prefix"`
}
type Guild struct {
	_ID      string   `bson:"_id"` // Guild ID
	ID       string   `bson:"id"`
	Settings Settings `bson:"settings"`
}

var (
	db         *mgo.Database
	DB         *mgo.Database
	err        error
	GuildError = Guild{
		"error",
		"error",
		Settings{
			"-",
		},
	}
	AwaitMessages      []interface{}
	AwaitMembers       []interface{}
	AwaitDeleteMembers []interface{}
)

func init() {
	session, err := mgo.Dial("localhost")
	if err != nil {
		logger.Error(fmt.Sprintf("Fatal: %v", err))
		log.Fatal(err)
	}
	db = session.DB("hue")
	DB = db

	guildsIndex := mgo.Index{
		Key:        []string{"id"},
		Unique:     true,
		DropDups:   true,
		Background: true,
		Sparse:     true,
	}

	err = db.C("guilds").EnsureIndex(guildsIndex)
	if err != nil {
		panic(err)
	}

	statsIndex := mgo.Index{
		Key:        []string{"id"},
		Unique:     true,
		DropDups:   true,
		Background: true,
		Sparse:     true,
	}

	err = db.C("stats").EnsureIndex(statsIndex)
	if err != nil {
		panic(err)
	}

	membersIndex := mgo.Index{
		Key:        []string{"id", "guildid"},
		Unique:     true,
		DropDups:   true,
		Background: true,
		Sparse:     true,
	}

	err = db.C("members").EnsureIndex(membersIndex)
	if err != nil {
		panic(err)
	}

	messagesIndex := mgo.Index{
		Key:        []string{"id", "guildid", "authorid"},
		Unique:     true,
		DropDups:   true,
		Background: true,
		Sparse:     true,
	}

	err = db.C("messages").EnsureIndex(messagesIndex)
	if err != nil {
		panic(err)
	}

	logger.Info(fmt.Sprintf("Connected to MongoDB"))
	//defer db.Close()

	// doEvery(InsertMessages)
	// doEvery(InsertMembers)
	// doEvery(DeleteMembers)
}

func Start() {
	logger.Info("Running InsertMessages")
	go doEvery(InsertMessages)
	logger.Info("Running InsertMembers")
	go doEvery(InsertMembers)
	logger.Info("Running DeleteMembers")
	go doEvery(DeleteMembers)
}

func doEvery(f func()) {
	for {
		time.Sleep(2 * time.Second)
		go f()
	}
}

func GetGuilds() ([]Guild, error) {
	var guilds []Guild
	err := db.C("guilds").Find(bson.M{}).All(&guilds)
	return guilds, err
}

func InsertMessages() {
	var Messages []interface{}
	Messages = AwaitMessages
	AwaitMessages = nil

	if len(Messages) == 0 {
		return
	} else {
		bulk := db.C("messages").Bulk()
		bulk.Unordered()
		bulk.Insert(Messages...)

		_, err := bulk.Run()
		if err != nil {
			logger.Error(fmt.Sprintf("InsertMessages (insert): %v", err))
		}
		// logger.Info(fmt.Sprintf("Inserted %v messages", len(Messages)))
	}
}
func InsertMembers() {
	var Members []interface{}
	Members = AwaitMembers
	AwaitMembers = nil

	if len(Members) == 0 {
		return
	}

	if len(Members) > 100000 {
		times := (len(Members) / 100000) + 1
		for i := 1; i <= times; i++ {
			bulk := db.C("members").Bulk()
			bulk.Unordered()
			bulk.Insert(Members[:100000]...)

			_, err := bulk.Run()
			if err != nil && !mgo.IsDup(err) {
				logger.Error(fmt.Sprintf("InsertMessages (insert): %v", err))
			}
			// logger.Info(fmt.Sprintf("Inserted %v members", len(Members)))

			Members = append(Members[:100000], Members[100001:]...)
		}
		bulk := db.C("members").Bulk()
		bulk.Unordered()
		bulk.Insert(Members...)

		_, err := bulk.Run()
		if err != nil && !mgo.IsDup(err) {
			logger.Error(fmt.Sprintf("InsertMessages (insert): %v", err))
		}
		// logger.Info(fmt.Sprintf("Inserted %v members", len(Members)))
	} else {
		bulk := db.C("members").Bulk()
		bulk.Unordered()
		bulk.Insert(Members...)

		_, err := bulk.Run()
		if err != nil && !mgo.IsDup(err) {
			logger.Error(fmt.Sprintf("InsertMessages (insert): %v", err))
		}
		// logger.Info(fmt.Sprintf("Inserted %v members", len(Members)))
	}

}
func DeleteMembers() {
	var Members []interface{}
	Members = AwaitDeleteMembers
	AwaitDeleteMembers = nil

	if len(Members) == 0 {
		return
	} else {
		for _, m := range Members {
			err = db.C("members").Remove(m)
			if err != nil {
				logger.Error(fmt.Sprintf("DeleteMembers (Remove): %v", err))
			}
		}
		// logger.Info(fmt.Sprintf("Removed %v members", len(Members)))
	}
}

func GetGuild(id string) (*Guild, error) {
	var guild Guild
	err := db.C("guilds").Find(bson.M{"id": id}).One(&guild)
	if err != nil {
		logger.Error(fmt.Sprintf("GetGuild: %v", err))
	}
	return &guild, err
}

func GetGuildStats(id string) (*GuildStats, error) {
	var stats GuildStats

	count, _ := db.C("members").Find(bson.M{"guildid": id}).Count()
	change := mgo.Change{
		Update: bson.M{"$set": bson.M{
			"totalmembers": count,
		}},
		ReturnNew: true,
	}
	_, err := db.C("stats").Find(bson.M{"id": id}).Apply(change, &stats)

	return &stats, err
}

func InsertStats(id string) (bool, error) {
	stats := &GuildStats{
		id,
		id,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
	}

	err3 := db.C("stats").Insert(&stats)
	if err3 != nil {
		logger.Error(fmt.Sprintf("AddGuild (err3): %v", err3))
		return false, err3
	} else {
		logger.Info("Successfully Added Guild Stats")
		return true, err3
	}
}

// Add guild to database
func AddGuild(g *discordgo.Guild) (*Guild, error) {
	count, err := db.C("guilds").Find(bson.M{"id": g.ID}).Count()
	if err != nil {
		logger.Error(fmt.Sprintf("AddGuild: %v", err))
		return &GuildError, err
	}

	if count > 0 {
		logger.Error("Guild Exists")
		return &GuildError, errors.New("Guild Exists")
	}
	if count > 1 {
		logger.Error(fmt.Sprintf("Removing excess member(s)(count: %v)", count))
		for count > 1 {
			RemoveGuild(g.ID)
		}
	}
	logger.Info("Adding Guild")
	guild := &Guild{
		g.ID,
		g.ID,
		Settings{
			"-",
		},
	}

	err2 := db.C("guilds").Insert(&guild)
	if err2 != nil {
		logger.Error(fmt.Sprintf("AddGuild (err2): %v", err))
	} else {
		logger.Info("Successfully Added Guild")
	}
	worked, _ := InsertStats(g.ID)
	backup := 0
	for worked == false || backup == 10 {
		_, _ = InsertStats(g.ID)
		backup++
	}
	for _, mem := range g.Members {
		if there := CheckMember(g.ID, mem.User.ID); !there {
			go AddMember(mem, g.ID)
		}
	}

	return guild, err
}

// RemoveGuild removes a guild from the database
func RemoveGuild(id string) error {
	var guild Guild

	err := db.C("guilds").Find(bson.M{"id": id}).One(&guild)
	if err != nil {
		logger.Error(fmt.Sprintf("RemoveGuild: %v", err))
		return err
	}

	err = db.C("guilds").Remove(&guild)
	if err != nil {
		logger.Error(fmt.Sprintf("RemoveGuild: %v", err))
		return err
	}

	var stats GuildStats

	err2 := db.C("stats").Find(bson.M{"id": id}).One(&stats)
	if err2 != nil {
		logger.Error(fmt.Sprintf("RemoveGuild (stats): %v", err))
		return err
	}

	err3 := db.C("stats").Remove(&stats)
	if err3 != nil {
		logger.Error(fmt.Sprintf("RemoveGuild (stats): %v", err))
	}

	return nil
}

func GetMessages(guildid string) ([]Message, error) {
	var messages []Message

	err := db.C("messages").Find(bson.M{"guildid": guildid}).All(&messages)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessages: %v", err))
	}

	return messages, err
}

func GetMessagesAT(guildid string) (int, error) {
	var stats GuildStats
	err := db.C("stats").Find(bson.M{"id": guildid}).All(&stats)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessagesAT: %v", err))
	}
	return stats.TotalMessages, err
}
func GetMessagesTMO(guildid string) ([]Message, error) {
	var messages []Message
	err := db.C("messages").Find(bson.M{
		"guildid":     guildid,
		"createdtime": bson.M{"$gte": time.Now().Add(-720 * time.Hour)},
	}).All(&messages)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessagesTMO: %v", err))
	}
	return messages, err
}
func GetMessagesTD(guildid string) ([]Message, error) {
	var messages []Message
	err := db.C("messages").Find(bson.M{
		"guildid":     guildid,
		"createdtime": bson.M{"$gte": time.Now().Add(-24 * time.Hour)},
	}).All(&messages)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessagesTD: %v", err))
	}
	return messages, err
}
func GetMessagesTH(guildid string) ([]Message, error) {
	var messages []Message
	err := db.C("messages").Find(bson.M{
		"guildid":     guildid,
		"createdtime": bson.M{"$gte": time.Now().Add(-1 * time.Hour)},
	}).All(&messages)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessagesTH: %v", err))
	}
	return messages, err
}
func GetMessagesTM(guildid string) ([]Message, error) {
	var messages []Message
	err := db.C("messages").Find(bson.M{
		"guildid":     guildid,
		"createdtime": bson.M{"$gte": time.Now().Add(-1 * time.Minute)},
	}).All(&messages)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessagesTM: %v", err))
	}
	return messages, err
}
func GetMembersTMO(guildid string) ([]Member, error) {
	var members []Member
	err := db.C("members").Find(bson.M{
		"guildid":  guildid,
		"joinedat": bson.M{"$gte": time.Now().Add(-720 * time.Hour)},
	}).All(&members)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMembersTMO: %v", err))
	}
	return members, err
}
func GetMembersTD(guildid string) ([]Member, error) {
	var members []Member
	err := db.C("members").Find(bson.M{
		"guildid":  guildid,
		"joinedat": bson.M{"$gte": time.Now().Add(-24 * time.Hour)},
	}).All(&members)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMembersTD: %v", err))
	}
	return members, err
}
func GetMembersTH(guildid string) ([]Member, error) {
	var members []Member
	err := db.C("members").Find(bson.M{
		"guildid":  guildid,
		"joinedat": bson.M{"$gte": time.Now().Add(-1 * time.Hour)},
	}).All(&members)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMembersTH: %v", err))
	}
	return members, err
}
func GetMembersTM(guildid string) ([]Member, error) {
	var members []Member
	err := db.C("members").Find(bson.M{
		"guildid":  guildid,
		"joinedat": bson.M{"$gte": time.Now().Add(-1 * time.Minute)},
	}).All(&members)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMembersTM: %v", err))
	}
	return members, err
}

func GetMessage(guildid, messageid string) (Message, error) {
	var message Message
	time.Sleep(2200 * time.Millisecond)
	err := db.C("messages").Find(bson.M{"id": messageid, "guildid": guildid}).One(&message)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMessage: %v", err))
	}

	return message, err
}

func AddMessage(m *discordgo.MessageCreate, msgmem *discordgo.Member) {
	// Get mention IDs
	var mentionIDs []string
	var message Message
	if len(m.Mentions) > 0 {
		for _, u := range m.Mentions {
			mentionIDs = append(mentionIDs, u.ID)

			var member Member
			change := mgo.Change{
				Update: bson.M{"$inc": bson.M{
					"timesmentioned": 1,
				}},
				ReturnNew: true,
			}
			_, err := db.C("members").Find(bson.M{"id": u.ID, "guildid": m.GuildID}).Apply(change, &member)

			if err != nil {
				logger.Error(fmt.Sprintf("AddMessage (Mentioned Member Missing): %v", err))
			}
		}
	} else {
		mentionIDs = nil
	}

	// Sort attachment data
	var Attachments []MessageAttachment
	if len(m.Attachments) > 0 {
		for _, v := range m.Attachments {
			Attachments = append(Attachments,
				MessageAttachment{
					v.ID,
					v.ID,
					v.URL,
					v.ProxyURL,
					v.Filename,
				})
		}
	} else {
		Attachments = nil
	}

	message = Message{
		m.ID,
		m.ID,
		time.Now(),
		m.ChannelID,
		m.GuildID,
		m.MentionRoles,
		m.Tts,
		m.MentionEveryone,
		m.Author.ID,
		Attachments,
		mentionIDs,
		m.Type,
		m.WebhookID,
	}
	count, err := db.C("members").Find(bson.M{"id": m.Author.ID, "guildid": m.GuildID}).Limit(1).Count()
	if err != nil {
		logger.Error(fmt.Sprintf("AddMessage (Member not found)(err != nil): %v", err))
	} else if count < 1 {
		logger.Error(fmt.Sprintf("AddMessage (Member not found)(Adding)"))
		go AddMember(msgmem, m.GuildID)
	} else {
		var member Member
		change := mgo.Change{
			Update: bson.M{"$inc": bson.M{
				"messagessent":    1,
				"attachmentssent": len(message.Attachments),
				"linkssent":       len(xurls.Relaxed().FindAllString(m.Content, -1)),
			}},
			ReturnNew: true,
		}
		_, err = db.C("members").Find(bson.M{"id": m.Author.ID, "guildid": m.GuildID}).Apply(change, &member)
		if err != nil {
			logger.Error(fmt.Sprintf("AddMessage (Change Member Stats): %v", err))
			go AddMember(msgmem, m.GuildID)
		}
		var stats GuildStats
		change = mgo.Change{
			Update: bson.M{"$inc": bson.M{
				"totalmessages":   1,
				"attachmentssent": len(message.Attachments),
				"linkssent":       len(xurls.Relaxed().FindAllString(m.Content, -1)),
				"mentions":        len(mentionIDs),
			}},
			ReturnNew: true,
		}
		_, err = db.C("stats").Find(bson.M{"id": m.GuildID}).Apply(change, &stats)

		if err != nil {
			logger.Error(fmt.Sprintf("AddMessage (stats): %v", err))
		}

		AwaitMessages = append(AwaitMessages, &message)

	}
}

func GetMembers(guildid string) ([]Member, error) {
	var members []Member
	err := db.C("members").Find(bson.M{"guildid": guildid}).All(&members)
	return members, err
}

func GetMember(guildid, memberid string) (Member, error) {
	var member Member
	err := db.C("members").Find(bson.M{"id": memberid, "guildid": guildid}).One(&member)
	if err != nil {
		logger.Error(fmt.Sprintf("GetMember: %v", err))
	}
	return member, err
}

func CheckMember(guildid, memberid string) bool {
	count, err := db.C("members").Find(bson.M{"id": memberid, "guildid": guildid}).Limit(1).Count()
	if err != nil {
		logger.Error(fmt.Sprintf("CheckMember: %v", err))
		return false

	} else if count > 0 {
		return true

	}
	return false
}

func AddMember(m *discordgo.Member, id string) (*Member, error) {
	var member *Member

	JoinedAt, _ := m.JoinedAt.Parse()

	// logger.Info(fmt.Sprintf("AddMember (Adding Member): %v", m.User.Username))
	member = &Member{
		m.User.ID,
		m.User.ID,
		id,
		JoinedAt,
		m.Nick,
		User{
			m.User.ID,
			m.User.Username,
			m.User.Avatar,
			m.User.Locale,
			m.User.Discriminator,
			m.User.Verified,
			m.User.Bot,
		},
		m.Roles,
		0,
		0,
		0,
		0,
	}

	if len(member.GuildID) < 5 {
		logger.Error(fmt.Sprintf("AddMember (Guild ID too short): %v", member.GuildID))
		return member, errors.New("Guild ID too short.")
	}

	AwaitMembers = append(AwaitMembers, member)

	return member, err
}

func RemoveMember(gid, mid string) error {
	var member bson.M

	member = bson.M{"guildid": gid, "id": mid}

	AwaitDeleteMembers = append(AwaitDeleteMembers, member)

	return nil
}

func SetPrefix(id, prefix string) error {
	var guild Guild
	change := mgo.Change{
		Update: bson.M{"$set": bson.M{
			"settings": bson.M{"prefix": prefix},
		}},
		ReturnNew: true,
	}
	_, err := db.C("guilds").Find(bson.M{"id": id}).Apply(change, &guild)

	if err != nil {
		logger.Error(fmt.Sprintf("SetPrefix: %v", err))
	}

	return err
}

func GetPrefix(id string) (string, error) {
	var guild Guild
	err := db.C("guilds").Find(bson.M{"id": id}).One(&guild)

	if err != nil {
		logger.Error(fmt.Sprintf("GetPrefix: %v", err))
	}

	prefix := guild.Settings.Prefix
	return prefix, err
}

func CheckUpToDate(g *discordgo.Guild, parentmembers []*discordgo.Member) chan bool {
	logger.Info(fmt.Sprintf("Checking %v {%v} Memebr count: %v", g.Name, g.ID, len(parentmembers)))

	var returnneededEdit = make(chan bool)
	var neededEdit = false
	guilds, err := GetGuilds()
	if err != nil {
		logger.Error(fmt.Sprintf("CheckUpToDate: %v", err))
	}
	if containsGuild(guilds, g) == false {
		AddGuild(g)
		neededEdit = false
	}
	statscount, _ := db.C("stats").Find(bson.M{"id": g.ID}).Limit(1).Count()
	if statscount < 1 {
		worked, _ := InsertStats(g.ID)
		backup := 0
		for worked == false || backup == 10 {
			_, _ = InsertStats(g.ID)
			backup++
		}
	}
	logger.Info(fmt.Sprintf("hm p2: %v", g.Name))
	// Re-populate with new
	for i := range parentmembers {
		go AddMember(parentmembers[i], g.ID)
	}

	prefix, err := GetPrefix(g.ID)
	if err == nil {
		if len(prefix) == 0 {
			SetPrefix(g.ID, "-")
		}
	}

	var rids []string
	var dbids []string
	var finalids []string
	var toremoveids []string

	var members []Member
	err = db.C("members").Find(bson.M{"guildid": g.ID}).All(&members)
	if err != nil {
		logger.Error(fmt.Sprintf("CheckUpToDate (All(&members)): %v", err))
	} else {
		for _, member := range parentmembers {
			rids = append(rids, member.User.ID)
		}
		for _, member := range members {
			dbids = append(dbids, member.User.ID)
		}
		for _, val := range dbids {
			for _, val2 := range rids {
				if val == val2 {
					finalids = append(finalids, val)
				}
			}
		}
		for _, val := range dbids {
			for _, val2 := range finalids {
				if val != val2 {
					exist, _ := in_array(val, finalids)
					if exist == false {
						toremoveids = append(toremoveids, val)
					}
				}
			}
		}
		toremoveids = unique(toremoveids)
		for _, v := range toremoveids {
			go RemoveMember(g.ID, v)
		}
	}

	var stats GuildStats
	var count int
	count, _ = db.C("members").Find(bson.M{"guildid": g.ID}).Count()
	change := mgo.Change{
		Update: bson.M{"$set": bson.M{
			"totalmembers": count,
		}},
		ReturnNew: true,
	}

	_, err = db.C("stats").Find(bson.M{"id": g.ID}).Apply(change, &stats)
	if err != nil {
		logger.Error(fmt.Sprintf("CheckUpToDate (stats): %v", err))
	}
	// var members []Member
	// _ = db.C("members").Find(bson.M{"guildid": g.ID}).All(&members)
	// for _, mem := range members {
	// 	for _, val := range g.Members {
	// 		if mem.User.ID != val.User.ID {
	// 			RemoveMember(g.ID, mem.User.ID)
	// 		}
	// 	}
	// }
	returnneededEdit <- neededEdit
	return returnneededEdit
}

func CheckUpToDateReady(r discordgo.Ready) error {
	var guilds []Guild
	var rids []string
	var dbids []string
	var finalids []string
	var toremoveids []string
	_ = db.C("guilds").Find(bson.M{}).All(&guilds)

	for _, guild := range r.Guilds {
		rids = append(rids, guild.ID)
	}
	for _, guild := range guilds {
		dbids = append(dbids, guild.ID)
	}
	for _, val := range dbids {
		for _, val2 := range rids {
			if val == val2 {
				finalids = append(finalids, val)
			}
		}
	}
	for _, val := range dbids {
		for _, val2 := range finalids {
			if val != val2 {
				exist, _ := in_array(val, finalids)
				if exist == false {
					toremoveids = append(toremoveids, val)
				}
			}
		}
	}
	toremoveids = unique(toremoveids)
	for _, v := range toremoveids {
		RemoveGuild(v)
	}

	for _, guild := range r.Guilds {
		AddGuild(guild)
	}

	return nil
}

// Used to check if value is in array
func containsGuild(arr []Guild, str *discordgo.Guild) bool {
	for _, a := range arr {
		if a.ID == str.ID {
			return true
		}
	}
	return false
}

func containsMember(id string, list []Member) bool {
	for _, b := range list {
		if b.User.ID == id {
			return true
		}
	}
	return false
}

func unique(intSlice []string) []string {
	keys := make(map[string]bool)
	list := []string{}
	for _, entry := range intSlice {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

func in_array(val interface{}, array interface{}) (exists bool, index int) {
	exists = false
	index = -1

	switch reflect.TypeOf(array).Kind() {
	case reflect.Slice:
		s := reflect.ValueOf(array)

		for i := 0; i < s.Len(); i++ {
			if reflect.DeepEqual(val, s.Index(i).Interface()) == true {
				index = i
				exists = true
				return
			}
		}
	}

	return
}

func GetStats() map[string]int {
	stats := make(map[string]int)

	iter := db.C("stats").Find(bson.M{"mentions": bson.M{"$gt": 0}}).Iter()
	mentions := 0
	var result GuildStats
	for iter.Next(&result) {
		mentions += result.Mentions
	}
	iter.Close()

	iter = db.C("stats").Find(bson.M{"linkssent": bson.M{"$gt": 0}}).Iter()
	links := 0
	var result2 GuildStats
	for iter.Next(&result2) {
		links += result2.LinksSent
	}
	iter.Close()

	iter = db.C("stats").Find(bson.M{"attachmentssent": bson.M{"$gt": 0}}).Iter()
	attachments := 0
	var result3 GuildStats
	for iter.Next(&result3) {
		attachments += result3.AttachmentsSent
	}
	iter.Close()

	stats["members"], _ = db.C("members").Count()
	stats["messages"], _ = db.C("messages").Count()
	stats["guilds"], _ = db.C("guilds").Count()
	stats["mentions"] = mentions
	stats["links"] = links
	stats["attachments"] = attachments

	return stats
}
