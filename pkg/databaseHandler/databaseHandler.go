package databaseHandler

import (
	"fmt"
	"os"
	"time"

	"github.com/asdine/storm"
	"github.com/bwmarrin/discordgo"
	"mvdan.cc/xurls"
)

type MessageAttachment struct {
	ID       string `storm:"index"`
	URL      string
	ProxyURL string
	Filename string
}

type User struct {
	ID            string `storm:"index"` // The ID of the user.
	Username      string // The user's username.
	Avatar        string // The hash of the user's avatar. Use Session.UserAvatar to retrieve the avatar itself.
	Locale        string // The user's chosen language option.
	Discriminator string // The discriminator of the user (4 numbers after name).
	Verified      bool   // Whether the user's email is verified.
	MFAEnabled    bool   // Whether the user has multi-factor authentication enabled.
	Bot           bool   // Whether the user is a bot.
}

type MentionUser struct {
	ID string `storm:"index"` // The ID of the user.
}

type Message struct {
	CreatedTime     time.Time             `storm:"inline"`
	ID              string                `storm:"unique, index"` // The ID of the message.
	ChannelID       string                // The ID of the channel in which the message was sent.
	GuildID         string                // The ID of the guild in which the message was sent.
	MentionRoles    []string              // The roles mentioned in the message.
	Tts             bool                  // Whether the message is text-to-speech.
	MentionEveryone bool                  // Whether the message mentions everyone.
	AuthorID        string                // The id of the author of the message.
	Attachments     []MessageAttachment   `storm:"inline"` // A list of attachments present in the message.
	Mentions        []string              // A list of users mentioned in the message.
	Type            discordgo.MessageType `storm:"inline"` // The type of the message.
	WebhookID       string                // The webhook ID of the message, if it was generated by a webhook
}

type Member struct {
	GuildID         string    // The guild ID on which the member exists.
	JoinedAt        time.Time `storm:"inline"` // The time at which the member joined the guild
	Nick            string    // The nickname of the member, if they have one.
	User            *User     `storm:"inline"` // The underlying user on which the member is based.
	Roles           []string  // A list of IDs of the roles which are possessed by the member.
	MessagesSent    int       // Number of messages the user has sent
	AttachmentsSent int       // Number of attachments the user has sent
	LinksSent       int       // Number of messages the user has sent

}
type GuildData struct {
	DataMessages map[string]Message `storm:"inline"`
	Members      map[string]Member  `storm:"inline"`
}
type GuildStats struct {
	TotalMessages int // Messages all time
	MessagesTM    int // Messages this month (last 30 days)
	MessagesTD    int // Messages this day (last 24h)
	MessagesTH    int // Messages this hour (last 60 minutes)
	MessagesTm    int // Messages this minute (last 60 seconds)

	TotalMembers int // Members all time
	MembersTM    int // Members this month (last 30 days)
	MembersTD    int // Members this day (last 24h)
	MembersTH    int // Members this hour (last 60 minutes)
	MembersTm    int // Members this minute (last 60 seconds)
}
type Guild struct {
	ID    string     `storm:"unique"` // Guild ID
	Data  GuildData  `storm:"inline"`
	Stats GuildStats `storm:"inline"`
}

var (
	db  *storm.DB
	err error
)

func init() {
	db, err = storm.Open("database-alpha.db")
	if err != nil {
		fmt.Println(err)
	}
	db.Init(&Guild{})

	//defer db.Close()
}

func GetGuilds() []Guild {
	var guilds []Guild
	err = db.All(&guilds)
	if err != nil {
		fmt.Println(err)
	}
	return guilds
}

func GetGuild(id string) Guild {
	var guild Guild
	err = db.One("ID", id, &guild)
	if err != nil {
		fmt.Println(err)
	}
	return guild
}

// Add guild to database
func AddGuild(g *discordgo.Guild) error {
	DataMessages := make(map[string]Message)
	Members := make(map[string]Member)
	fmt.Printf("\nMEMBERS: %v\n", g.Members)
	for _, member := range g.Members {
		JoinedAt, _ := member.JoinedAt.Parse()
		Members[member.User.ID] = Member{
			member.GuildID, // The guild ID on which the member exists.
			JoinedAt,       // The time at which the member joined the guild
			member.Nick,    // The nickname of the member, if they have one.
			&User{
				member.User.ID,
				member.User.Username,
				member.User.Avatar,
				member.User.Locale,
				member.User.Discriminator,
				member.User.Verified,
				member.User.MFAEnabled,
				member.User.Bot,
			},
			member.Roles, // A list of IDs of the roles which are possessed by the member.
			0,
			0,
			0,
		}
	}

	guildData := GuildData{
		DataMessages,
		Members,
	}

	guildStats := GuildStats{
		0, // Messages all time
		0, // Messages this day (last 24h)
		0, // Messages this month (last 30 days)
		0, // Messages this hour (last 60 minutes)
		0, // Messages this minute (last 60 seconds)

		g.MemberCount, // Members all time
		0,             // Members this day (last 24h)
		0,             // Members this month (last 30 days)
		0,             // Members this hour (last 60 minutes)
		0,             // Members this minute (last 60 seconds)
	}

	guild := Guild{
		g.ID,
		guildData,
		guildStats,
	}

	err = db.Save(&guild)
	if err != nil {
		fmt.Println(err)
	}

	return nil
}

// RemoveGuild removes a guild from the database
func RemoveGuild(id string) error {
	var guild Guild
	err := db.One("ID", id, &guild)
	if err != nil {
		fmt.Println(err)
		return err
	}
	err = db.DeleteStruct(&guild)
	if err != nil {
		fmt.Println(err)
		return err
	}
	return nil
}

func GetMessages(guildid, messageid string) map[string]Message {
	var messages map[string]Message
	var guild Guild

	err = db.One("ID", guildid, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[message] %s\n", err)
	}

	messages = guild.Data.DataMessages

	return messages
}

func GetMessage(guildid, messageid string) Message {
	var message Message
	var guild Guild

	err = db.One("ID", guildid, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[message] %s\n", err)
	}

	message = guild.Data.DataMessages[messageid]

	return message
}

func AddMessage(m *discordgo.MessageCreate) error {
	// Get mention IDs
	var mentionIDs []string
	if len(m.Mentions) > 0 {
		for _, v := range m.Mentions {
			mentionIDs = append(mentionIDs, v.ID)
		}
	} else {
		mentionIDs = nil
	}

	// Sort attachment data
	var Attachments []MessageAttachment
	if len(m.Attachments) > 0 {
		for _, v := range m.Attachments {
			Attachments = append(Attachments,
				MessageAttachment{
					v.ID,
					v.URL,
					v.ProxyURL,
					v.Filename,
				})
		}
	} else {
		Attachments = nil
	}

	message := Message{
		time.Now(),
		m.ID,
		m.ChannelID,
		m.GuildID,
		m.MentionRoles,
		m.Tts,
		m.MentionEveryone,
		m.Author.ID,
		Attachments,
		mentionIDs,
		m.Type,
		m.WebhookID,
	}

	var guild Guild
	err = db.One("ID", m.GuildID, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[AddMessage] %s\n", err)
	}

	if _, ok := guild.Data.Members[m.Author.ID]; !ok {
		return fmt.Errorf("[AddMessage] %s\n", "User not in database.")
	}

	guild.Data.DataMessages[m.ID] = message
	guild.Data.Members[m.Author.ID] = Member{
		guild.Data.Members[m.Author.ID].GuildID,
		guild.Data.Members[m.Author.ID].JoinedAt,
		guild.Data.Members[m.Author.ID].Nick,
		guild.Data.Members[m.Author.ID].User,
		guild.Data.Members[m.Author.ID].Roles,
		guild.Data.Members[m.Author.ID].MessagesSent + 1,
		guild.Data.Members[m.Author.ID].AttachmentsSent,
		guild.Data.Members[m.Author.ID].LinksSent,
	}

	if len(message.Attachments) > 0 {
		guild.Data.Members[m.Author.ID] = Member{
			guild.Data.Members[m.Author.ID].GuildID,
			guild.Data.Members[m.Author.ID].JoinedAt,
			guild.Data.Members[m.Author.ID].Nick,
			guild.Data.Members[m.Author.ID].User,
			guild.Data.Members[m.Author.ID].Roles,
			guild.Data.Members[m.Author.ID].MessagesSent,
			guild.Data.Members[m.Author.ID].AttachmentsSent + len(message.Attachments),
			guild.Data.Members[m.Author.ID].LinksSent,
		}
	}

	if len(xurls.Relaxed().FindAllString(m.Content, -1)) > 0 {
		guild.Data.Members[m.Author.ID] = Member{
			guild.Data.Members[m.Author.ID].GuildID,
			guild.Data.Members[m.Author.ID].JoinedAt,
			guild.Data.Members[m.Author.ID].Nick,
			guild.Data.Members[m.Author.ID].User,
			guild.Data.Members[m.Author.ID].Roles,
			guild.Data.Members[m.Author.ID].MessagesSent,
			guild.Data.Members[m.Author.ID].AttachmentsSent,
			guild.Data.Members[m.Author.ID].LinksSent + len(xurls.Relaxed().FindAllString(m.Content, -1)),
		}
	}

	err := db.Save(&guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[AddMessage] %s\n", err)
	}

	return nil
}

func GetMembers(guildid string) map[string]Member {
	var members map[string]Member
	var guild Guild

	err = db.One("ID", guildid, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[GetMembers] %s\n", err)
	}

	members = guild.Data.Members

	return members
}

func GetMember(guildid, memberid string) Member {
	var member Member
	var guild Guild

	err = db.One("ID", guildid, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[GetMember] %s\n", err)
	}

	member = guild.Data.Members[memberid]

	return member
}

func AddMember(m *discordgo.Member) error {
	var guild Guild

	err = db.One("ID", m.GuildID, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[GetMembers] %s\n", err)
	}

	JoinedAt, _ := m.JoinedAt.Parse()
	guild.Data.Members[m.User.ID] = Member{
		m.GuildID, // The guild ID on which the member exists.
		JoinedAt,  // The time at which the member joined the guild
		m.Nick,    // The nickname of the member, if they have one.
		&User{
			m.User.ID,
			m.User.Username,
			m.User.Avatar,
			m.User.Locale,
			m.User.Discriminator,
			m.User.Verified,
			m.User.MFAEnabled,
			m.User.Bot,
		},
		m.Roles, // A list of IDs of the roles which are possessed by the member.
		0,
		0,
		0,
	}

	err = db.Save(&guild)
	if err != nil {
		fmt.Println(err)
	}

	return nil
}

func RemoveMember(gid, mid string) error {
	var guild Guild

	err = db.One("ID", gid, &guild)
	if err != nil {
		fmt.Fprintf(os.Stderr, "[GetMembers] %s\n", err)
	}

	delete(guild.Data.Members, mid)

	err = db.Save(&guild)
	if err != nil {
		fmt.Println(err)
	}

	return nil
}

func CheckUpToDate(r *discordgo.Ready) error {
	guilds := GetGuilds()
	for _, guild := range r.Guilds {
		if !containsGuild(guilds, guild) {
			AddGuild(guild)
		}
	}
	// Re-populate with new
	for _, guild := range r.Guilds {
		guildlocal := GetGuild(guild.ID)
		members := guildlocal.Data.Members
		for _, mem := range guild.Members {
			if _, ok := members[mem.User.ID]; !ok {
				AddMember(mem)
			}
		}
	}
	return nil
}

// Used to check if value is in array
func containsGuild(arr []Guild, str *discordgo.Guild) bool {
	for _, a := range arr {
		if a.ID == str.ID {
			return true
		}
	}
	return false
}
func containsMember(arr []Member, str *discordgo.Member) bool {
	for _, a := range arr {
		if a.User.ID == str.User.ID {
			return true
		}
	}
	return false
}
